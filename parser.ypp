%{
    #include<iostream>
    #include "hw3_output.hpp"
    #include "types.h"
    using namespace std;
    using namespace output;

    int yylex();
    void yyerror(char const*);
    extern int yylineno;
%}

%%union{
    TypeNode* typeNode;
    FuncNode* funcNode;
    ProgramNode* programNode;
    FuncsDeclNode* funcsDeclNode;
    RetTypeNode* retTypeNode;
    FormalsNode* formalsNode;
    FormalsListNode* formalsListNode;
    FormalDeclNode* formalDeclNode;
    StatementsNode* statementsNode;
    StatementNode* statementNode;
    CallNode* callNode;
    ExpListNode* expListNode;
    ExpNodeNode* expNodeNode;
}

%token NUM
%token VOID
%token INT
%token BYTE
%token B
%token BOOL


%token TRUE
%token FALSE
%token RETURN

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token STRING
%nonassoc IF

%left ASSIGN

%left OR
%left AND

%left RELOP

%left ADD_MIN
%left MUL_DIV

%right NOT

%left RPAREN
%left LPAREN

%nonassoc ELSE

%%
Program: Funcs {table.start_program();} Funcs {table.end_program(yychar, YYEOF, yylineno);}


 Funcs: /*epsilon*/ {}
		| FuncDecl Funcs {}


 FuncDecl: RetType ID LPAREN Formals RPAREN {table.create_func($1, $2, $4, yylineno);} LBRACE Statements RBRACE
 {tables.pop_scope();}


 RetType: Type {$$ = $1;}
		  | VOID {$$ = TypeNode(VOID);}

//todo null
 Formals : /*epsilon*/ {$$ = nullptr;}
		  | FormalsList {$$ = $1;}

FormalsList : FormalDecl {$$ = $1; }
			  | FormalDecl COMMA FormalsList { $1.next = $3; $3.back = $1; $$ = $1;}


 FormalDecl : Type ID {$$ = new NodeParams($1, $2);}


 Statements: Statement {}
			 | Statements Statement {}


 Statement: LBRACE {table.push_scope();} Statements RBRACE {table.pop_scope();}
            | Type ID SC {table.insert_symbol($1,$2, yylineno);}
			| Type ID ASSIGN Exp SC {table.insert_and_check_symbol($1,$2,$4, yylineno);}
			| ID ASSIGN Exp SC {table.check_symbol($1, $3, yylineno);}
			| Call SC {table.check_func($1);}
			| RETURN SC {table.check_return();}
			| RETURN Exp SC {table.check_return($2.type);}
			| IF LPAREN Exp RPAREN Statement {table.check_exp_is_bool($3);}
			| IF LPAREN Exp RPAREN Statement ELSE Statement {table.check_exp_is_bool($3);}
			| WHILE LPAREN Exp RPAREN Statement {table.check_exp_is_bool($3);}
			| BREAK SC {table.check_break();}
			| CONTINUE SC {table.check_continue();} //Inside while


Call: ID LPAREN ExpList RPAREN {$$ = funcCallNode($1, $3);}
      | ID LPAREN RPAREN {$$ = funcCallNode($1);}


ExpList: Exp {$$ = $1;}
         | Exp COMMA ExpList {$1.next = $3; $3.back = $1; $$ = $1;}


Type: INT {$$=TypeNode(INT)}
      | BYTE {$$=TypeNode(BYTE)}
	  | BOOL {$$=TypeNode(BOOL)}

Exp: LPAREN Exp RPAREN {$$ = $2}
	 | Exp IF LPAREN Exp RPAREN ELSE Exp {$$ = table.find_type_from_tri($1,$4,$7);}
     | Exp ADD_MIN Exp {$$ = table.find_type_from_add_min($1, $3);}
     | Exp MUL_DIV Exp {$$ = table.find_type_from_mul_div($1, $3);}
	 | ID {$$ = table.find_type_from_id($1) //type node;}
	 | Call {$$ = table.find_type_from_call_func($1);}
	 | NUM {$$ = TypeNode(INT);}
	 | NUM B {$$ = TypeNode(BYTE);}
	 | STRING {$$ = TypeNode(STRING);}
	 | TRUE {$$ = TypeNode(BOOL);}
	 | FALSE {$$ = TypeNode(BOOL);}
	 | NOT Exp {$$ = TypeNode(BOOL);}// todo checks
	 | Exp AND Exp {$$ = TypeNode(BOOL);}
	 | Exp OR Exp {$$ = TypeNode(BOOL);}
	 | Exp RELOP Exp {$$ = TypeNode(BOOL);}
	 | LPAREN Type RPAREN Exp {$$ = TypeNode($2.type);}

%%

int main()
{
    return yyparse();
}

void yyerror(char const* s){
    errorSyn(yylineno);
}